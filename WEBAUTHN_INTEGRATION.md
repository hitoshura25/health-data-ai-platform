# WebAuthn Stack Integration Guide

This document describes how the Health Data AI Platform integrates with the WebAuthn authentication stack.

## Architecture Overview

The platform uses **two separate Docker Compose stacks** for security isolation:

### 1. WebAuthn Stack (`webauthn-stack/`)
**Purpose**: Authentication, authorization, and observability infrastructure

**Components**:
- **Envoy Gateway** (port 8000) - Entry point with JWT verification
- **WebAuthn Server** - FIDO2/Passkey authentication + JWT issuer
- **PostgreSQL** (port 5433) - Credentials and passkey storage only
- **Redis** (port 6380) - Session storage only
- **Jaeger** (port 16687) - Distributed tracing for ALL services
- **Example Service** - Python FastAPI JWT verification reference

**Generated by**: `@vmenon25/mcp-server-webauthn-client` MCP tool

### 2. Health Services Stack (main `docker-compose.yml`)
**Purpose**: Health data processing and storage

**Components**:
- **Health API Service** - FastAPI upload/query service
- **PostgreSQL** (port 5432) - Health data storage
- **Redis** (port 6379) - Rate limiting cache
- **MinIO** (ports 9000/9001) - Data lake
- **RabbitMQ** (ports 5672/15672) - Message queue
- **Data Lake Service** - Object storage management
- **Message Queue Service** - Async processing
- **ETL Narrative Engine** (future) - Clinical data processing
- **AI Query Interface** (future) - MLflow-powered queries

## Design Rationale

### Why Separate Stacks?

#### ✅ Security Isolation
- **Credentials isolated**: WebAuthn database only contains authentication data
- **Blast radius limited**: Compromise of health data doesn't expose credentials
- **Principle of least privilege**: Health services cannot access credential store

#### ✅ Independent Scaling
- Scale authentication independently from data processing
- Different resource requirements (auth is lightweight, data processing is heavy)
- Can replace WebAuthn with different auth provider without touching health services

#### ✅ Technology Independence
- WebAuthn stack uses Java (hitoshura25/webauthn-server)
- Health services use Python (FastAPI)
- Each optimized for its domain

### Why Shared Jaeger?

#### ✅ Distributed Tracing Requires Cross-Service Visibility
```
User Request Flow:
1. Client → WebAuthn (authenticate)       [Span 1]
2. Client → Health API (upload)           [Span 2]
   ├─ Health API → Data Lake (store)      [Span 3]
   └─ Health API → Message Queue (async)  [Span 4]

All spans must be in ONE Jaeger instance to correlate!
```

#### ✅ Single Observability Dashboard
- One UI to monitor entire platform: `http://localhost:16687`
- See authentication latency impacting API performance
- Root cause analysis across service boundaries

#### ✅ Production Best Practice
In production, you typically have:
- **One centralized observability stack** (Jaeger, Prometheus, Grafana)
- **Multiple application stacks** (all send traces to shared Jaeger)

This mirrors that architecture in development.

## Starting the Platform

### Quick Start

```bash
# 1. Start WebAuthn stack (authentication + Jaeger)
cd webauthn-stack/docker && docker compose up -d && cd ../..

# 2. Start health services
docker compose up -d

# 3. Verify all services
docker ps
```

### Startup Order

**Critical**: Always start WebAuthn stack **before** health services.

**Why?**
- Health services will send traces to Jaeger (must be running)
- Future: Health API will verify JWTs (needs WebAuthn server)

### Verification

```bash
# Check WebAuthn stack
curl http://localhost:8000/health  # Gateway health
curl http://localhost:16687        # Jaeger UI

# Check health services
curl http://localhost:5432         # PostgreSQL (should connect)
curl http://localhost:9000         # MinIO (login screen)
docker compose logs health-api     # Check for startup errors
```

## Service Integration Patterns

### 1. Adding Distributed Tracing to Health Services

When implementing OpenTelemetry in Python services:

```python
# Example: services/health-api-service/src/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Jaeger configuration (points to webauthn-stack Jaeger)
    jaeger_otlp_endpoint: str = "http://localhost:4319"  # gRPC
    jaeger_service_name: str = "health-api"

    class Config:
        env_prefix = "HEALTH_API_"

# Example: services/health-api-service/src/tracing.py
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

def setup_tracing(settings: Settings):
    """Configure OpenTelemetry to send traces to shared Jaeger"""

    # Use WebAuthn stack's Jaeger
    otlp_exporter = OTLPSpanExporter(
        endpoint=settings.jaeger_otlp_endpoint,
        insecure=True  # For local development
    )

    trace.set_tracer_provider(TracerProvider())
    trace.get_tracer_provider().add_span_processor(
        BatchSpanProcessor(otlp_exporter)
    )

    return trace.get_tracer(settings.jaeger_service_name)
```

**Docker Compose Configuration**:

```yaml
# services/health-api-service/health-api.compose.yml
services:
  health-api:
    environment:
      # Jaeger tracing (uses webauthn-stack Jaeger)
      - HEALTH_API_JAEGER_OTLP_ENDPOINT=http://host.docker.internal:4319
      - HEALTH_API_JAEGER_SERVICE_NAME=health-api
```

**Note**: Use `host.docker.internal` to access the WebAuthn stack's Jaeger from the health services network.

### 2. JWT Verification (Future Implementation)

When Health API needs to verify WebAuthn JWTs:

#### Step 1: Fetch Public Key

```python
# One-time setup during service initialization
import requests

WEBAUTHN_PUBLIC_KEY_URL = "http://localhost:8000/public-key"

def fetch_webauthn_public_key() -> str:
    """Fetch RS256 public key from WebAuthn server"""
    response = requests.get(WEBAUTHN_PUBLIC_KEY_URL)
    response.raise_for_status()
    return response.text  # PEM format
```

#### Step 2: Verify JWT

```python
import jwt
from fastapi import HTTPException, Security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

# Load public key at startup (cache it)
WEBAUTHN_PUBLIC_KEY = fetch_webauthn_public_key()

def verify_webauthn_jwt(
    credentials: HTTPAuthorizationCredentials = Security(security)
) -> dict:
    """Verify WebAuthn JWT and return payload"""
    token = credentials.credentials

    try:
        payload = jwt.decode(
            token,
            WEBAUTHN_PUBLIC_KEY,
            algorithms=["RS256"],
            issuer="webauthn-server",  # Must match WebAuthn issuer
            options={
                "verify_signature": True,
                "verify_exp": True,
                "verify_iss": True,
            }
        )
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token expired")
    except jwt.InvalidSignatureError:
        raise HTTPException(401, "Invalid token signature")
    except Exception as e:
        raise HTTPException(401, f"Token validation failed: {e}")

# Use in protected endpoints
from fastapi import Depends

@app.post("/api/upload")
async def upload_health_data(
    jwt_payload: dict = Depends(verify_webauthn_jwt)
):
    user_id = jwt_payload["sub"]
    # Process upload...
```

#### Step 3: Token Exchange Pattern (Recommended)

Instead of passing WebAuthn JWTs everywhere, exchange them for Health API tokens:

```python
@app.post("/auth/token-exchange")
async def exchange_webauthn_token(
    webauthn_jwt: str,
    db: AsyncSession = Depends(get_db)
):
    """
    Exchange WebAuthn JWT for Health API token

    Flow:
    1. Verify WebAuthn JWT
    2. Look up or create user in health database
    3. Issue Health API JWT with service-specific permissions
    """

    # Verify WebAuthn JWT
    webauthn_payload = verify_jwt(webauthn_jwt, WEBAUTHN_PUBLIC_KEY)
    webauthn_user_id = webauthn_payload["sub"]

    # Map to health user
    user = await get_or_create_health_user(db, webauthn_user_id)

    # Issue Health API token
    health_token = create_health_api_jwt(user.id, permissions=user.permissions)

    return {"access_token": health_token, "token_type": "bearer"}
```

**Detailed Examples**: See `webauthn-stack/docs/INTEGRATION.md` for complete code samples.

## Port Reference

### WebAuthn Stack Ports
| Service | Internal Port | Host Port | Purpose |
|---------|--------------|-----------|---------|
| Envoy Gateway | 8000 | 8000 | Main entry point |
| Envoy Admin | 9901 | 9901 | Gateway admin UI |
| WebAuthn Server | 8080 | - | Internal only |
| PostgreSQL | 5432 | 5433 | Credentials DB |
| Redis | 6379 | 6380 | Sessions |
| Jaeger UI | 16686 | 16687 | Tracing UI |
| Jaeger OTLP gRPC | 4317 | 4319 | Trace ingestion (gRPC) |
| Jaeger OTLP HTTP | 4318 | 4320 | Trace ingestion (HTTP) |

### Health Services Ports
| Service | Internal Port | Host Port | Purpose |
|---------|--------------|-----------|---------|
| Health API | 8000 | 8001 | REST API |
| PostgreSQL | 5432 | 5432 | Health data DB |
| Redis | 6379 | 6379 | Rate limiting |
| MinIO API | 9000 | 9000 | S3-compatible API |
| MinIO Console | 9001 | 9001 | Web UI |
| RabbitMQ AMQP | 5672 | 5672 | Message queue |
| RabbitMQ Management | 15672 | 15672 | Management UI |

**Note**: Custom ports for WebAuthn stack prevent conflicts with health services.

## Network Architecture

### Current Setup (Separate Networks)

```
┌─────────────────────────────────────┐
│  webauthn-stack (default network)   │
│  - envoy-gateway                    │
│  - webauthn-server                  │
│  - postgres (5433)                  │
│  - redis (6380)                     │
│  - jaeger (16687)                   │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  health-platform-net                │
│  - health-api                       │
│  - postgres (5432)                  │
│  - redis (6379)                     │
│  - minio                            │
│  - rabbitmq                         │
└─────────────────────────────────────┘
```

**Communication**: Services communicate via `host.docker.internal` (localhost on host machine).

**Advantages**:
- ✅ Complete isolation between stacks
- ✅ Can manage stacks independently
- ✅ No shared network means no accidental coupling

**Disadvantages**:
- ⚠️ Slightly higher latency (goes through host network)
- ⚠️ Requires `host.docker.internal` support (works on Docker Desktop, may need config on Linux)

### Alternative: Shared Network (Future Consideration)

If you need direct container-to-container communication:

```yaml
# In webauthn-stack/docker/docker-compose.yml
networks:
  default:
    external: true
    name: health-platform-net

# In main docker-compose.yml
networks:
  health-platform-net:
    driver: bridge
    name: health-platform-net
```

Then services can access each other directly:
- `http://webauthn-server:8080` (instead of `http://localhost:8000`)
- `http://jaeger:4317` (instead of `http://host.docker.internal:4319`)

**When to use**: If latency becomes an issue or deploying to production Kubernetes.

## Troubleshooting

### WebAuthn Stack Won't Start

```bash
# Check if ports are already in use
lsof -i :8000   # Envoy gateway
lsof -i :16687  # Jaeger UI
lsof -i :5433   # PostgreSQL
lsof -i :6380   # Redis

# View logs
cd webauthn-stack/docker
docker compose logs -f

# Restart from scratch
docker compose down -v
docker compose up -d
```

### Health Services Can't Connect to Jaeger

**Symptom**: Traces not appearing in Jaeger UI

**Solution**:
```bash
# 1. Verify Jaeger is running
curl http://localhost:16687

# 2. Check health service configuration
docker compose logs health-api | grep -i jaeger

# 3. Test OTLP endpoint
curl http://localhost:4319  # Should connect (gRPC)

# 4. Verify host.docker.internal works
docker run --rm alpine ping host.docker.internal
```

### JWT Verification Failing

**Symptom**: 401 errors with "Invalid signature"

**Solutions**:
```bash
# 1. Verify public key is accessible
curl http://localhost:8000/public-key

# 2. Check JWT algorithm
# Must be RS256, not HS256

# 3. Verify issuer claim
# JWT must have "iss": "webauthn-server"

# 4. Check token expiration
# Tokens expire in 15 minutes by default
```

## Migration Path

### From Old Setup to New Setup

The project previously had separate WebAuthn and Jaeger compose files in the infrastructure directory.

These have been **removed** in favor of the MCP-generated stack:
- ✅ More complete (includes Envoy Gateway, example service)
- ✅ Better security (Docker secrets, mTLS)
- ✅ Maintained by MCP (stays up-to-date)
- ✅ Follows zero-trust architecture

**No action needed** - migration is complete.

## Future Enhancements

### 1. Service Mesh Integration
Add Istio/Linkerd sidecars to health services to use the same mTLS patterns as webauthn-stack.

### 2. API Gateway
Move Health API behind Envoy Gateway for unified entry point:
- `http://localhost:8000/auth/*` → WebAuthn
- `http://localhost:8000/api/*` → Health API (JWT required)

### 3. Monitoring Stack
Add to webauthn-stack:
- Prometheus (metrics)
- Grafana (dashboards)
- Loki (logs)

All health services would send telemetry to this shared observability stack.

## References

- **WebAuthn Stack README**: `webauthn-stack/README.md`
- **Integration Examples**: `webauthn-stack/docs/INTEGRATION.md`
- **WebAuthn Server Docs**: https://github.com/hitoshura25/mpo-api-authn-server
- **MCP Server**: https://github.com/hitoshura25/mpo-api-authn-server/tree/main/mcp-server-webauthn-client
- **OpenTelemetry Python**: https://opentelemetry.io/docs/instrumentation/python/
- **Jaeger Documentation**: https://www.jaegertracing.io/docs/

---

**Last Updated**: 2025-10-21
**Architecture Decision**: Separate stacks with shared Jaeger for distributed tracing
